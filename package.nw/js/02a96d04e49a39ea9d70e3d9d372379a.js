;!function(require, directRequire){;"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const tslib_1=require("tslib"),WebSocket=require("ws"),eventemitter3_1=require("eventemitter3"),config_1=require('./a148d3a11fd5268109e21fb40c9d527b.js'),utils_1=require('./46d7303eb986fa402d60bf5e929aa077.js'),index_1=require('./1c9e324c5ce9b5feb007c03bcb3f41dc.js'),log_1=require('./56a764ae9cb4336bf6babe1c1da0275b.js'),{getNewTicket}=require('./89ba85d67a88f7636d657c22b5d3e038.js'),log=log_1.default("[messager]"),logInvoke=utils_1.logInvoke(log),logStack=utils_1.logStack(log),MAX_MISSED_MESSAGE_COUNT=2,MAX_AUTO_RETRY_COUNT=3,MAX_CACHED_SEND_GROUP_COUNT=10;function responseTypeForDataFormat(a){switch(a.cmd){case config_1.RequestCmd.Login:return config_1.ResponseType.Login;case config_1.RequestCmd.EventNotifyBegin:return config_1.ResponseType.EventNotifyBegin;case config_1.RequestCmd.EventNotifyBlock:return config_1.ResponseType.EventNotifyBlock;case config_1.RequestCmd.EventNotifyEnd:return config_1.ResponseType.EventNotifyEnd;case config_1.RequestCmd.Heartbeat:return config_1.ResponseType.Heartbeat;case config_1.RequestCmd.JoinRoom:return config_1.ResponseType.JoinRoom;case config_1.RequestCmd.MessageNotify:return config_1.ResponseType.MessageNotify;case config_1.RequestCmd.MessageNotifyParallelly:return config_1.ResponseType.MessageNotifyParallelly;case config_1.RequestCmd.QuitRoom:return config_1.ResponseType.QuitRoom;case config_1.RequestCmd.SendDebugMessage:return config_1.ResponseType.SendDebugMessage;case config_1.RequestCmd.SendDebugMessageParallelly:return config_1.ResponseType.SendDebugMessageParallelly;case config_1.RequestCmd.SyncMessage:return config_1.ResponseType.SyncMessage;default:return config_1.ResponseType.Unknown;}}function commentForRequestType(a){return config_1.RequestType[a]}function commentForResponseType(a){return config_1.ResponseType[a]}function retryDelayForRetryCount(a){return 0===a?100:1===a?500:2===a?1e3:3===a?3e3:0}function sorterForDebugMessage(c,a){return c.seq-a.seq}exports.sorterForDebugMessage=sorterForDebugMessage;var ConnectionStatus;(function(a){a[a.Dead=-1]="Dead",a[a.Unintialized=0]="Unintialized",a[a.Disconnected=1]="Disconnected",a[a.Logout=2]="Logout",a[a.LoginHanged=3]="LoginHanged",a[a.Waiting=4]="Waiting",a[a.ServerBlocked=5]="ServerBlocked",a[a.ActiveHanged=6]="ActiveHanged",a[a.ActiveIdle=7]="ActiveIdle"})(ConnectionStatus=exports.ConnectionStatus||(exports.ConnectionStatus={}));class Messager extends eventemitter3_1.EventEmitter{constructor(a){super(),this.status=ConnectionStatus.Unintialized,this.inSpeed=0,this.outSpeed=0,this.outDebugMessageSpeed=0,this.inDebugMessageSpeed=0,this.tempDir="",this.autoLoopingTimeout=void 0,this.inCount=0,this.outCount=0,this.outDebugMessageCount=0,this.inDebugMessageCount=0,this.inBytesCount=0,this.outBytesCount=0,this.ws=null,this.loggedIn=!1,this.debugMessagesCollectionTimeout=void 0,this.needSendHeartbeat=!1,this.receivedSeq=0,this.managedSeq=0,this.lastSendSeq=0,this.serverAck=0,this.managedDebugTimestamp=NaN,this.lastDebugMessageSendTimestamp=Date.now(),this.missedMessageCount=0,this.sendQueue=[],this.receivedDebugMessages=[],this.debugMessagesToSend=[],this.cachedDebugMessageSendGroups=[],this.lastSendTimestamp=0,this.lastSyncTimestamp=0,this.destroyed=!1,this.roomInfo=null,this.resolvers={},this.retryCount=0,this.serverErrorRetryCount=0,this.serverErrorStamp=void 0,this._restarting=!1,this._retrying=!1,this._askForRetryFn=()=>Promise.resolve(!1),this.dataSendReports=[],this.reportCounter=0,this.dataSendReportTimer=void 0,this.compressionSavedBytes=0,this.tempDir=a.tempDir,this.initialRoomInfo=a.initialRoomInfo}init(){if(this._restarting=!1,this.missedMessageCount=0,this.status<=ConnectionStatus.Dead)return log.w("cannot init a dead instance"),!1;global.ms=this,this.setStatus(ConnectionStatus.Disconnected),this.ws&&(this.ws.removeAllListeners(),utils_1.tryCatch(()=>this.ws.close()),this.ws=null),log.i("websocket instance generated");const a=this.ws=new WebSocket(config_1.RemoteUrl);return a.addEventListener("message",this.onWsMessage.bind(this)),a.addEventListener("close",this.onWsClose.bind(this)),a.addEventListener("error",this.onWsError.bind(this)),a.addEventListener("open",this.onWsOpen.bind(this)),!0}getBaseRequestTemplate(){return{clientversion:utils_1.clientVersion}}onWsMessage(a){this.missedMessageCount=0,++this.inCount;let b;if(!a)return log.w("received empty message from ws",a),void log.f("<RECEIVED>  <EMPTY>  "+a);if(Buffer.isBuffer(a))b=a;else if("string"==typeof a)b=Buffer.from(a);else if(Buffer.isBuffer(a.data))b=a.data;else if("string"==typeof a.data)b=Buffer.from(a.data);else return log.w("received invalid message from ws",a),void log.f("<RECEIVED>  <INVALID>  "+a);this.inBytesCount+=b.byteLength||0;let c;if(c=utils_1.tryCatch(()=>index_1.unwrapProtoToDataFormat(b)),utils_1.invalidTryCatchResult(c)){log.e("received response data broken",c.error.stack,a),log.f("<RECEIVED>  <BROKEN>  "+a);const b={type:"receivedbrokenmessage",message:c.error.message};return void this.emit("event",b)}c&&c.data||(log.w("received data with no inner data",c.data),log.f("<RECEIVED>  <EMPTY INNERDATA>  "+c.data),c.data={});const d=c.data,e=responseTypeForDataFormat(c);if(d.hasOwnProperty("base_response")){const a=(d.base_response||{}).errcode;if(a&&a!==config_1.KnownErrorCode.OK)return log.e("received error code",a,utils_1.isDev?utils_1.jsonStringify(d):d),utils_1.isDev&&log.f("<RECEIVED>  <ERROR CODE>  "+utils_1.jsonStringify(c.data)),this.resolvers[e]&&(log.w("rejecting resolvers[",config_1.ResponseType[e],"]"),this.resolvers[e].reject(d),delete this.resolvers[e]),void this.onErrorCode(a,c.uuid||"")}if(log.f("<RECEIVED>  "+utils_1.jsonStringify({"(cmd)":e,"(uuid)":c.uuid})),this.setStatusByResponse(e),this.resolvers[e]&&(this.resolvers[e].resolve(d),delete this.resolvers[e]),e===config_1.ResponseType.Login)return void this.onReceiveLoginResponse(d);if(e===config_1.ResponseType.Heartbeat)return void this.onReceiveHeartbeatResponse();if(e===config_1.ResponseType.JoinRoom)return void this.onReceiveJoinRoomResponse(d);if(e===config_1.ResponseType.MessageNotify||e===config_1.ResponseType.MessageNotifyParallelly)return this.onReceiveDebugMessage(d),void(d.send_ack&&this.onReceiveServerSendAck(d));if(e===config_1.ResponseType.SendDebugMessageParallelly)return this.onReceiveSendDebugMessageParallellyResponse(d),void(d.send_ack&&this.onReceiveServerSendAck(d));if(e===config_1.ResponseType.EventNotifyBegin)return void this.onReceiveBeginEvent();if(e===config_1.ResponseType.EventNotifyBlock)return void this.onReceiveBlockEvent();if(e===config_1.ResponseType.EventNotifyEnd)return void this.onReceiveEndEvent();if(e===config_1.ResponseType.QuitRoom)return void this.onReceiveQuitRoomResponse();if(e===config_1.ResponseType.SyncMessage)return this.onReceiveDebugMessage(d),void(d.send_ack&&this.onReceiveServerSendAck(d));this.emit("event",{type:"receivedinvalidmessage"}),log.w("received invalid cmd",c.cmd,"type",e,config_1.ResponseType[e])}onReceiveDebugMessage(a){if("array"!==utils_1.typeOf(a.debug_message)&&(a.debug_message=[]),1>a.debug_message.length)return;log.f("(onReceiveDebugMessage) "+a.debug_message.map((a)=>a.seq).join(",")),this.inDebugMessageCount+=a.debug_message.length;const b=[...a.debug_message];if(b.push(...this.receivedDebugMessages),this.receivedDebugMessages=[],b.sort(sorterForDebugMessage),this.receivedSeq+1<b[0].seq)return log.e("received minimum seq",b[0].seq,"larger than received seq",this.receivedSeq),this.receivedDebugMessages.push(...b),log.w("current received seqs",this.receivedDebugMessages),this.emit("accident"),void this.syncDebugMessages(b[0].seq);const c=[];let d=-1;for(const e of b){if(++d,e.seq<=this.receivedSeq)continue;const a=c[c.length-1];if(a){if(a.seq===e.seq)continue;if(a.seq+1!==e.seq)break}else if(this.receivedSeq+1!==e.seq)break;c.push(e)}const e=b.slice(d+1);if(this.receivedDebugMessages.push(...e),1>c.length)return void log.i("nothing new to debug.");const f=c[c.length-1].seq;this.receivedSeq=f,0<e.length&&(log.w("although some debug messages can be emited, there is still something missed for range [",this.receivedSeq+1,",",e[0].seq-1,"]"),this.syncDebugMessages(e[0].seq),this.emit("accident")),0==this.receivedSeq%20&&this.sendDidReceiveMessageImmediately();for(const b of c)this.emit("debugmessage",b)}sendDidReceiveMessageImmediately(){this.needSendHeartbeat=!0}syncDebugMessages(a=Infinity){this.lastSyncTimestamp=Date.now();const b={base_request:this.getBaseRequestTemplate(),min_seq:this.receivedSeq,serialized_uuid:`sync-${this.receivedSeq}`};isFinite(a)&&a>this.receivedSeq&&(b.max_seq=a,b.serialized_uuid=`sync-${this.receivedSeq}-${a}`),this.send(b,config_1.RequestType.SyncMessage)}sendDebugMessage(a,b,c,d){var e=Math.max;const f=c&&c.len||0,g={seq:++this.managedSeq,delay:0,category:b,data:a,_len:f,compress_algo:d};if(b!==config_1.DebugMessageCategory.Ping){const a=c&&"number"==typeof c.timestamp?c.timestamp:Date.now();g.delay=isNaN(this.managedDebugTimestamp)?0:e(0,a-this.managedDebugTimestamp),this.managedDebugTimestamp=e(this.managedDebugTimestamp,a)}this.debugMessagesToSend.push(g),this.startCollectDebugMessages()}startCollectDebugMessages(a=17){if(!this.debugMessagesCollectionTimeout){const b=Date.now()-this.lastDebugMessageSendTimestamp;17>b&&(a=34),this.debugMessagesCollectionTimeout=setTimeout(()=>{this.sendDebugMessagesImmediately()},Math.max(0,a-b))}}packTestSendGroup(){const a=this.debugMessagesToSend.slice(0,10);if(1>a.length)return void log.i("no debug message to pack");const b={base_request:this.getBaseRequestTemplate(),debug_message:a,recv_ack:this.receivedSeq,serialized_uuid:`dm-${a[0].seq}-${a[a.length-1].seq}-(test)-${Date.now()}`};let c=0;for(const b of a)c+=b._len||0;const d={lastSentTimestamp:Date.now(),sendDebugMessageRequest:b,confirmed:!1,dataSize:c};return d}sendDebugMessagesImmediately(){if(clearTimeout(this.debugMessagesCollectionTimeout),this.debugMessagesCollectionTimeout=void 0,this.status<ConnectionStatus.ActiveIdle)return void log.w("status",this.status,"not ready sending new messages");const a=this.debugMessagesToSend;if(this.debugMessagesToSend=[],1>a.length)return void log.i("nothing new to send");let b=0,c=0;const d=[0],e=[];let f=0;for(const g=a.length;f<g;f++)b+=a[f]._len||0,c+=a[f]._len||0,64000<b&&(log.w("reached size limit 64K, lens =",b,"@",f),d.push(f+1),e.push(b),b=0);(2>d.length||d[d.length-1]<a.length)&&(d.push(a.length),e.push(b));const g=Date.now();for(let b=1,f=d.length;b<f;b++){const f=a.slice(d[b-1],d[b]);if(1>f.length)continue;const h={base_request:this.getBaseRequestTemplate(),debug_message:f,recv_ack:this.receivedSeq,serialized_uuid:`dm-${f[0].seq}-${f[f.length-1].seq}-${b}/${d.length-1}-(${e[b-1]})-${g}`},i={lastSentTimestamp:g,sendDebugMessageRequest:h,confirmed:!1,dataSize:c};this.cachedDebugMessageSendGroups.push(i),this.send(h,config_1.RequestType.SendDebugMessageParallelly)}this.lastDebugMessageSendTimestamp=g}checkCachedSendGroups(a=!1){const b=this.cachedDebugMessageSendGroups,c=[],d=[],e=Date.now();for(const f of b)f.confirmed||(c.push(f),(2e4<=e-f.lastSentTimestamp||a)&&d.push(f));if(this.cachedDebugMessageSendGroups=c,0<d.length){if(log.w("some messages missed, shall resending",d.length,"send groups"),!a&&this.status<ConnectionStatus.ActiveIdle)return void log.w("not ready resending messages");log.f("(checkCachedSendGroups) forceResend="+(a+" >> resends seqs :: ")+d.map((a)=>{return a.sendDebugMessageRequest.debug_message.map((a)=>a.seq).join(", ")}).join(", "));for(const b of d)b.lastSentTimestamp=e,this.send(b.sendDebugMessageRequest,config_1.RequestType.SendDebugMessageParallelly,a)}this.startCollectDebugMessages()}testSendDebugMessage(){let a;for(const b of this.cachedDebugMessageSendGroups)if(!b.confirmed){a=b;break}a||(a=this.packTestSendGroup()),a?(a.lastSentTimestamp=Date.now(),this.send(a.sendDebugMessageRequest,config_1.RequestType.SendDebugMessageParallelly,!0)):log.w("no test debug message to send")}onReceiveServerSendAck(a){let b=a.send_ack;if("number"!==utils_1.typeOf(b)&&(b=parseInt(b+"",10),isNaN(b))){const c={type:"receivedinvalidmessage",message:"invalid send_ack "+a.send_ack};return this.emit("event",c),void log.e("received invalid type of send_ack",b)}if(utils_1.expect(b,log).as((a)=>{return a>=this.serverAck&&a<=this.lastSendSeq}).fail(()=>{const a={type:"servererror",message:"send_ack invalid "+b,kind:"error"};this.emit("event",a)}),b<=this.serverAck||b>this.lastSendSeq)return;log.f("(onReceiveServerSendAck)  "+b),this.serverAck=Math.max(b,this.serverAck);let c=0;for(const b of this.cachedDebugMessageSendGroups){if(b.confirmed)continue;const a=b.sendDebugMessageRequest.debug_message;a[a.length-1].seq<=this.serverAck?b.confirmed=!0:c+=1}this.status===ConnectionStatus.ActiveHanged&&c<MAX_CACHED_SEND_GROUP_COUNT&&(log.i("server confirms some messages, switch back to active idle"),this.setStatus(ConnectionStatus.ActiveIdle),this.checkCachedSendGroups())}onReceiveSendDebugMessageParallellyResponse(a){const b=parseInt(a.max_ack,10),c=parseInt(a.min_ack,10);if(isNaN(b)||isNaN(c)){log.w("invalid acks",a.min_ack,a.max_ack);const b={type:"receivedinvalidmessage",message:"received invalid acks "+a.min_ack+", "+a.max_ack};return void this.emit("event",b)}log.f("(onReceiveSendDebugMessageParallellyResponse) "+c+", "+b);let d=0,e=!1;for(const f of this.cachedDebugMessageSendGroups){if(f.confirmed)continue;const a=f.sendDebugMessageRequest.debug_message;if(a[0].seq===c){utils_1.expect(a[a.length-1].seq,log).toBe(b).fail(()=>{log.e("ack range invalid");this.emit("event",{type:"receivedinvalidmessage",message:"received invalid ack ranges "+c+", "+b})}),f.confirmed=!0;const d={cost_time:Date.now()-f.lastSentTimestamp,data_size:f.dataSize,message_count:f.sendDebugMessageRequest.debug_message.length};this.dataSendReports.push(d),e=!0;break}else d+=1}if(e||log.w_("min and max ack not found",c,b),this.status===ConnectionStatus.ActiveHanged&&d<MAX_CACHED_SEND_GROUP_COUNT)log.i("server confirms some messages, switch back to active idle"),this.setStatus(ConnectionStatus.ActiveIdle),this.checkCachedSendGroups();else if(this.status===ConnectionStatus.ServerBlocked){log.i("received regular response for debug message, switch back to active idle"),this.setStatus(ConnectionStatus.ActiveIdle),this.checkCachedSendGroups();this.emit("event",{type:"serverblock",blocked:!1,kind:"event"})}}reportDataSend(){const a=this.dataSendReports;this.emit("datasendreport",a),this.dataSendReports=[]}setStatus(a){if(this.status!==a){const b=this.status;this.status=a,this.emit("statuschange",a,b)}}processSendQueue(){if(!(1>this.sendQueue.length)){const a=[...this.sendQueue];this.sendQueue=[];for(const b of a)b.type!==config_1.RequestType.Unknown&&(log.i("process send queue item",b),this.send(b.msg,b.type))}}onErrorCode(a,b){let c=!0;if(config_1.KnownErrorCode.hasOwnProperty(a)?c=this.onKnownErrorCode(a,b):log.e("unknown error",a),c){const c={type:"receivederrorcode",errorCode:a,errorMessage:config_1.KnownErrorCode[a],message:"received error code "+a+" on "+b,kind:"error"};this.emit("event",c)}}onKnownErrorCode(a,b){let c=!0;switch(a){case config_1.KnownErrorCode.OK:break;case config_1.KnownErrorCode.SYSTEM_BUSY:{if(log.e("system busy"),this.serverErrorStamp&&(b||"").startsWith(this.serverErrorStamp))this.serverErrorRetryCount+=1;else{const a=(b||"").match(/^dm-\d+-/i);a&&a[0]&&(this.serverErrorStamp=a[0]),this.serverErrorRetryCount=0}if(3<this.serverErrorRetryCount){this.emit("event",{type:"servererror",message:"Server Busy",kind:"error"}),this.destroy()}else this.checkCachedSendGroups(!0),this.syncDebugMessages();break}case config_1.KnownErrorCode.ERR_SYS:case config_1.KnownErrorCode.NOT_EXIST:case config_1.KnownErrorCode.INVALID_ARGS:{log.e("internal error",a);break}case config_1.KnownErrorCode.INVALID_LOGIN_TICKET:{log.w("login error"),this.destroy();break}case config_1.KnownErrorCode.HAS_NO_PERMISSION:{log.w("no permission error"),this.destroy();break}case config_1.KnownErrorCode.ROOM_IN_DEBUGGING:{log.w("room already in debugging status"),this.destroy();break}case config_1.KnownErrorCode.NO_EXIST_ROOM:{log.w("could not find room"),this.destroy();break}case config_1.KnownErrorCode.MD5_NOT_MATCH:{log.w("md5 not matching");break}case config_1.KnownErrorCode.USER_IN_DEBUGGING:{log.w("user already in debugging status"),this.destroy();break}case config_1.KnownErrorCode.SEQ_ERROR:{log.w("send seq error");break}case config_1.KnownErrorCode.SEND_MSG_BUSY:{log.w("send msg busy error"),this.onServerSendMessageBusy(),c=!1;break}case config_1.KnownErrorCode.SEND_MSG_SEQ_RANGE_ERROR:{log.w("send seq range error");break}default:{utils_1.expectFail.fail(()=>{utils_1.assertNever(a),log.e("known error code",a)});break}}return c}onServerSendMessageBusy(){if(this.status>ConnectionStatus.ServerBlocked){this.setStatus(ConnectionStatus.ServerBlocked);this.emit("event",{type:"serverblock",blocked:!0,message:"send message busy",kind:"warn"})}else log.w("no need to change status to ServerBlocked")}onWsClose(){return this._restarting||this._retrying?void log.i("websocket close while restarting or retrying."):void(this.status>=ConnectionStatus.Disconnected?(this.setStatus(ConnectionStatus.Disconnected),log.e("websocket close"),log.f("<CLOSE>"),this.retryIfNeeded()):log.w("received close event while status",this.status,"< Disconnected."))}onAskForRetry(a){this._askForRetryFn=a}async retryIfNeeded(){if((this._restarting||this._retrying)&&log.i("no need to retry"),this._retrying=!0,this.retryCount>=MAX_AUTO_RETRY_COUNT)if("function"===utils_1.typeOf(this._askForRetryFn)){let a=!1;try{a=await this._askForRetryFn(this.retryCount+1),a=!!a}catch(b){log.e("calling askForRetryFn with error",b),a=!1}if(!a)return log.i("askForRetryFn: no"),void this.destroy();log.i("askForRetryFn: yes")}else return void log.w("askForRetryFn broken");++this.retryCount;const a=retryDelayForRetryCount(this.retryCount);await utils_1.delayPromise(a),this._retrying=!1,this.restart()}onWsError(a){this.setStatus(ConnectionStatus.Disconnected);const b=a&&a.stack?a.stack:a;log.e("websocket error",b),log.f("<ERROR>  "+b);const c={type:"sessionerror",kind:"error",message:"websocket error "+a.message||a};this.emit("event",c),this.retryIfNeeded()}onWsOpen(){this.retryCount=0,this.enableAutoLoop(),this.login()}enableAutoLoop(){this.autoLoopingTimeout&&(log.i("already auto looping"),clearTimeout(this.autoLoopingTimeout));let a=0,b=0;const c=this.speedCalcFn(),d=()=>{const e=Date.now();c.call(this),(this.needSendHeartbeat||15000<=e-this.lastSendTimestamp)&&this.sendHeartbeat(),this.status>ConnectionStatus.Waiting&&15000<e-this.lastSyncTimestamp&&this.syncDebugMessages(),1e4<e-a&&(a=e,this.checkCachedSendGroups()),3e4<e-b&&(b=e,this.reportDataSend()),this.status===ConnectionStatus.ServerBlocked&&this.testSendDebugMessage(),this.autoLoopingTimeout=setTimeout(d,2e3)};this.autoLoopingTimeout=setTimeout(d,0)}speedCalcFn(){const a=(()=>{let a=this.inCount,b=this.outCount,c=this.outDebugMessageCount,d=this.inDebugMessageCount,e=this.inBytesCount,f=this.outBytesCount,g=Date.now();return()=>{var h=Math.round;if(this.inCount!==a||this.outCount!==b||this.outDebugMessageCount!==c||this.inDebugMessageCount!==d||this.inBytesCount!==e||this.outBytesCount!==f){const i=Date.now();this.compressionSavedBytes=index_1.model.getCompressionSavedBytes(),this.inSpeed=h(1e3*((this.inCount-a)/(i-g))),this.outSpeed=h(1e3*((this.outCount-b)/(i-g))),this.outDebugMessageSpeed=h(1e3*((this.outDebugMessageCount-c)/(i-g))),this.inDebugMessageSpeed=h(1e3*((this.inDebugMessageCount-d)/(i-g))),a=this.inCount,b=this.outCount,c=this.outDebugMessageCount,d=this.inDebugMessageCount,e=this.inBytesCount,f=this.outBytesCount,g=i,this.emit("statuschange",this.status,void 0)}}})();return a}async restart(a=!1){return this._restarting?void log.i("already restarting"):void(this._restarting=!0,a&&(this.cachedDebugMessageSendGroups=[],this.sendQueue=[],this.missedMessageCount=0,this.serverErrorRetryCount=0,this.serverErrorStamp=void 0,this.receivedSeq=0,this.managedSeq=0,this.lastSendSeq=0,this.serverAck=0,this.debugMessagesCollectionTimeout&&(clearTimeout(this.debugMessagesCollectionTimeout),this.debugMessagesCollectionTimeout=void 0),this.receivedDebugMessages=[]),this.status>ConnectionStatus.Logout&&(await(()=>new Promise((a)=>{this.resolvers[config_1.ResponseType.QuitRoom]={resolve:a,reject:a},this.quit(),setTimeout(a,5e3)}))()),this.init())}sendHeartbeat(){this.needSendHeartbeat=!1;const a={base_request:this.getBaseRequestTemplate(),recv_ack:this.receivedSeq,serialized_uuid:`hb-${Date.now()}`};this.send(a,config_1.RequestType.Heartbeat)}onTimeout(){if(log.e("on timeout detected"),this.status>ConnectionStatus.Disconnected){this.setStatus(ConnectionStatus.Disconnected);this.emit("event",{type:"sessionerror",kind:"warn",message:"websocket timeout"}),this.retryIfNeeded()}else log.w("ontimeout while status <= disconnected")}async login(){this.setStatus(ConnectionStatus.Logout);let a;try{a=await getNewTicket()}catch(a){log.e("get ticket error",a);const b={type:"sessionerror",kind:"error",message:"login get ticket error "+(a&&a.message?a.message:a)};return this.emit("event",b),void this.retryIfNeeded()}const b={newticket:a,base_request:this.getBaseRequestTemplate(),serialized_uuid:`login-${a}`};this.send(b,config_1.RequestType.Login)||log.w("sending login request refused")}onReceiveHeartbeatResponse(){}onReceiveJoinRoomResponse(){}onReceiveQuitRoomResponse(){}onReceiveLoginResponse(a){const b=a.room_info;if(!b||!b.join_room)return log.i("not yet in a room. join one."),this.roomInfo={room_id:this.initialRoomInfo.room_id},void this.requestJoinRoom();if(!this.roomInfo||this.roomInfo.room_id!==b.room_id){log.w("losing context, restart");this.emit("event",{type:"losingcontext"}),this.restart(!0)}else{log.w("recover from current context"),this.setStatus(ConnectionStatus.ActiveIdle),this.syncDebugMessages(),this.processSendQueue();this.emit("event",{type:"recoverfromcurrentcontext",kind:"event"})}}requestJoinRoom(){const a={base_request:this.getBaseRequestTemplate(),room_id:this.initialRoomInfo.room_id,wxpkg_info:this.initialRoomInfo.wxpkg_info,username:this.initialRoomInfo.username,appid:this.initialRoomInfo.appid,serialized_uuid:`join-${this.initialRoomInfo.room_id}`};this.send(a,config_1.RequestType.JoinRoom)}onReceiveBeginEvent(){}onReceiveBlockEvent(){this.emit("event",{type:"serverblock",blocked:!0,message:"received server block",kind:"warn"}),this.onServerSendMessageBusy()}onReceiveEndEvent(){if(this._restarting||this._retrying)return void log.i("retrying or restarting, no need to suicide.");this.quit();this.emit("event",{type:"end",kind:"event"}),this.destroy()}shouldSend(a){const b=this.status;return a===config_1.RequestType.EventNotifyBlock||a===config_1.RequestType.EventNotifyEnd||a===config_1.RequestType.EventNotifyBegin||a===config_1.RequestType.QuitRoom||a===config_1.RequestType.Heartbeat||a===config_1.RequestType.Login?b>=ConnectionStatus.Logout:a===config_1.RequestType.JoinRoom?b>=ConnectionStatus.LoginHanged:a===config_1.RequestType.SyncMessage||a===config_1.RequestType.MessageNotifyParallelly||a===config_1.RequestType.MessageNotify?b>=ConnectionStatus.ServerBlocked:a===config_1.RequestType.Unknown||a===config_1.RequestType.SendDebugMessageParallelly||a===config_1.RequestType.SendDebugMessage?b>=ConnectionStatus.ActiveIdle:(utils_1.assertNever(a),!1)}pushToSendQueue(a,b){var c=Math.max;switch(b){case config_1.RequestType.SyncMessage:{const d=this.sendQueue.findIndex((a)=>a.type===b);if(0>d)this.sendQueue.push({msg:a,type:b});else{const b=this.sendQueue[d].msg;b.min_seq=Math.min(a.min_seq,b.min_seq);const e=a.max_seq,f=b.max_seq;e&&f?b.max_seq=c(e,f):delete b.max_seq}break}case config_1.RequestType.SendDebugMessageParallelly:break;case config_1.RequestType.SendDebugMessage:{this.sendQueue;let c=!1;for(const d of this.sendQueue)if(d.type===b){utils_1.expect(d.msg,log).as((b)=>{return 1>b.debug_message.length||1>a.debug_message.length||b.debug_message[0].seq>=a.debug_message[0].seq}).fail(()=>{this.emit("event",{type:"sendinginvalidmessage",message:"trying to send debug messages seq larger than send queue"})}),d.msg=a,c=!0;break}c||this.sendQueue.push({msg:a,type:b});break}case config_1.RequestType.QuitRoom:case config_1.RequestType.Login:case config_1.RequestType.Heartbeat:{const d=this.sendQueue.findIndex((a)=>a.type===b);if(0>d)this.sendQueue.push({msg:a,type:b});else{const b=this.sendQueue[d].msg;b.recv_ack=c(b.recv_ack,a.recv_ack)}break}case config_1.RequestType.JoinRoom:{0>this.sendQueue.findIndex((a)=>a.type===b)&&this.sendQueue.push({msg:a,type:b});break}default:{this.sendQueue.push({msg:a,type:b});break}}}setStatusByRequest(a){let b=!1;switch(a){case config_1.RequestType.QuitRoom:{this.status>ConnectionStatus.Logout?this.setStatus(ConnectionStatus.Logout):log.w("request quit room while status <= logout"),b=!0;break}case config_1.RequestType.Login:{this.status<ConnectionStatus.LoginHanged?this.setStatus(ConnectionStatus.LoginHanged):log.w("request login while status >= loginhanged"),b=!0;break}case config_1.RequestType.JoinRoom:{this.status<ConnectionStatus.Waiting?this.setStatus(ConnectionStatus.Waiting):log.w("request join room while status >= Waiting"),b=!0;break}case config_1.RequestType.SendDebugMessage:{this.status>ConnectionStatus.ActiveHanged?this.setStatus(ConnectionStatus.ActiveHanged):log.w("request send debug message while status <= activehanged"),b=!0;break}case config_1.RequestType.SendDebugMessageParallelly:break;default:{b=!0;break}}b&&this.processSendQueue()}setStatusByResponse(a){let b=!1;switch(a){case config_1.ResponseType.Login:{this.status<ConnectionStatus.LoginHanged?log.w("received login response with no login request"):this.status>=ConnectionStatus.Waiting?log.w("received login response while waiting"):this.setStatus(ConnectionStatus.LoginHanged),b=!0;break}case config_1.ResponseType.EventNotifyBegin:{this.status<ConnectionStatus.Waiting?log.w("received begin event while not waiting",this.status):this.setStatus(ConnectionStatus.ActiveIdle),b=!0;break}case config_1.ResponseType.EventNotifyEnd:{this.status<ConnectionStatus.Logout?log.w("received end event while not yet login"):this.setStatus(ConnectionStatus.Logout),b=!0;break}case config_1.ResponseType.EventNotifyBlock:{this.status<ConnectionStatus.Waiting?log.w("received block event while waiting"):this.setStatus(ConnectionStatus.ServerBlocked),b=!0;break}case config_1.ResponseType.SendDebugMessageParallelly:{this.status<ConnectionStatus.ServerBlocked?log.w("received send debug message response while not joint room"):this.status===ConnectionStatus.ActiveHanged&&log.w("response cannot change the status of active hanged"),b=!0;break}case config_1.ResponseType.SyncMessage:{this.status<ConnectionStatus.ActiveHanged?log.i("received sync message response while server blocked"):this.setStatus(ConnectionStatus.ActiveIdle),b=!0;break}default:{b=!0;break}}b&&this.processSendQueue()}quit(){if(this.status<=ConnectionStatus.Logout)return void log.w("no need to quit");1<this.sendQueue.length&&log.w("quiting with non-empty send queue"),this.autoLoopingTimeout&&(clearTimeout(this.autoLoopingTimeout),this.autoLoopingTimeout=void 0);const a={base_request:this.getBaseRequestTemplate(),serialized_uuid:`quit-${Date.now()}`};this.send(a,config_1.RequestType.QuitRoom,!0)||log.w("quit room failed")}send(a,b,c=!1){if(!c&&!this.shouldSend(b)){if(log.i("sending message of type",b,"has been delayed, status = ",this.status),this.pushToSendQueue(a,b),200<this.sendQueue.length){this.emit("event",{type:"queuetoomanyrequest",kind:"error"})}return!1}const d=a.serialized_uuid?a.serialized_uuid:utils_1.randomId(),e=utils_1.tryCatch(()=>index_1.wrapOutgoingToProto(a,b,d));if(utils_1.invalidTryCatchResult(e)){log.e("trying to send a broken structure",e.error.stack,a);const b={type:"sendingbrokenmessage",kind:"error",message:e.error.message};return this.emit("event",b),!1}if(!this.sendImmediately(e,b))return this.pushToSendQueue(a,b),!1;if(log.f("<SEND>  "+utils_1.jsonStringify({"(cmd)":b,"(uuid)":d})),b===config_1.RequestType.SendDebugMessageParallelly){utils_1.expect(a,log).as((a)=>{const b=a.debug_message;return!(1>b.length)}).fail(()=>{this.emit("event",{type:"assertion",message:"just sent an empty debug message",kind:"error"})}),utils_1.expect(a,log).as((a)=>{const b=a.debug_message;if(!b[0])return!0;let c=b[0].seq-1;for(const d of b){if(c+1!==d.seq)return!1;++c}return!0}).fail(()=>{const b={type:"sendinginvalidmessage",message:"sending seq not well ordered "+a.serialized_uuid};this.emit("event",b)});const b=a.debug_message||[];0<b.length&&(this.lastSendSeq=Math.max(this.lastSendSeq,b[b.length-1].seq),this.outDebugMessageCount+=b.length)}return!0}sendImmediately(a,b){if(this.ws){if(this.missedMessageCount>=MAX_MISSED_MESSAGE_COUNT)return log.e("heart beat timeout"),this.onTimeout(),!1;this.setMissedMessageCountByRequest(b);const c=index_1.uint8ArrayToBuffer(a);return this.ws.send(c,{binary:!0}),++this.outCount,this.outBytesCount+=c.byteLength||0,this.lastSendTimestamp=Date.now(),this.setStatusByRequest(b),!0}return log.e("ws is not initialized sending message"),!1}setMissedMessageCountByRequest(a){a!==config_1.RequestType.SyncMessage&&a!==config_1.RequestType.SendDebugMessageParallelly&&a!==config_1.RequestType.QuitRoom&&++this.missedMessageCount}destroy(){return this.destroyed?void log.w("messager has already been destroyed"):void(this.destroyed=!0,this.ws&&(this.quit(),this.ws.removeAllListeners(),utils_1.tryCatch(()=>this.ws.close())),this.ws=null,this.setStatus(ConnectionStatus.Dead),this.autoLoopingTimeout&&clearTimeout(this.autoLoopingTimeout),this.debugMessagesCollectionTimeout&&clearTimeout(this.debugMessagesCollectionTimeout),this.autoLoopingTimeout=void 0,this.sendQueue=[],this.receivedDebugMessages=[],this.debugMessagesToSend=[],this.debugMessagesCollectionTimeout=void 0,index_1.model.resetStatistics(),this.emit("destroy"))}}tslib_1.__decorate([logInvoke],Messager.prototype,"onWsMessage",null),tslib_1.__decorate([logInvoke],Messager.prototype,"onReceiveDebugMessage",null),tslib_1.__decorate([logInvoke],Messager.prototype,"packTestSendGroup",null),tslib_1.__decorate([logInvoke],Messager.prototype,"sendDebugMessagesImmediately",null),tslib_1.__decorate([logInvoke],Messager.prototype,"checkCachedSendGroups",null),tslib_1.__decorate([logInvoke],Messager.prototype,"testSendDebugMessage",null),tslib_1.__decorate([logInvoke],Messager.prototype,"onReceiveServerSendAck",null),tslib_1.__decorate([logInvoke],Messager.prototype,"onReceiveSendDebugMessageParallellyResponse",null),tslib_1.__decorate([logInvoke],Messager.prototype,"setStatus",null),tslib_1.__decorate([logInvoke],Messager.prototype,"onErrorCode",null),tslib_1.__decorate([logInvoke],Messager.prototype,"onKnownErrorCode",null),tslib_1.__decorate([logInvoke],Messager.prototype,"onServerSendMessageBusy",null),tslib_1.__decorate([logInvoke],Messager.prototype,"onWsClose",null),tslib_1.__decorate([logStack],Messager.prototype,"retryIfNeeded",null),tslib_1.__decorate([logInvoke],Messager.prototype,"onWsError",null),tslib_1.__decorate([logInvoke],Messager.prototype,"onWsOpen",null),tslib_1.__decorate([logInvoke],Messager.prototype,"enableAutoLoop",null),tslib_1.__decorate([logStack],Messager.prototype,"restart",null),tslib_1.__decorate([logStack],Messager.prototype,"onTimeout",null),tslib_1.__decorate([logInvoke],Messager.prototype,"login",null),tslib_1.__decorate([logInvoke],Messager.prototype,"onReceiveHeartbeatResponse",null),tslib_1.__decorate([logInvoke],Messager.prototype,"onReceiveJoinRoomResponse",null),tslib_1.__decorate([logInvoke],Messager.prototype,"onReceiveQuitRoomResponse",null),tslib_1.__decorate([logInvoke],Messager.prototype,"onReceiveLoginResponse",null),tslib_1.__decorate([logInvoke],Messager.prototype,"requestJoinRoom",null),tslib_1.__decorate([logInvoke],Messager.prototype,"onReceiveBeginEvent",null),tslib_1.__decorate([logInvoke],Messager.prototype,"onReceiveBlockEvent",null),tslib_1.__decorate([logInvoke],Messager.prototype,"onReceiveEndEvent",null),tslib_1.__decorate([logInvoke],Messager.prototype,"setStatusByRequest",null),tslib_1.__decorate([logInvoke],Messager.prototype,"quit",null),tslib_1.__decorate([logInvoke],Messager.prototype,"sendImmediately",null),tslib_1.__decorate([logStack],Messager.prototype,"destroy",null),exports.Messager=Messager;
;}(require("lazyload"), require);
